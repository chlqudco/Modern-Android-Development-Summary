- 구글에서는 앱을 안정적으로 만들 수 있도록 안드로이드 앱 아키텍처 가이드를 제공한다
	- 가이드에 따라서 만들어진 앱은 견고하고 고품질이 된다.
	- 이유를 알기 위해 역사를 알아햐 한다

- 컴퓨터 프로그램을 만들면서 반복적으로 사용 가능한 효율적인 구조가 있단걸 알게 됨
	- 그걸 아키텍처 패턴이란 이름으로 정리함
	- 대상 시스템에 따라 아키텍쳐 패턴은 다양 하지만 안드로이드는 보통 MVC, MVP, MVVM 이 사용됨

- 1970년대 MVC가 도입
- 1990년대 MVC를 개선한 MVP를 도입
- 2005년 MVVM패턴을 도입

- 패턴을 도입하는 핵심 목적은 관심사를 분리함으로써 간결하고 확장하기 쉽게 만들기 위함

- 어떻게 관심사를 분리한다는 것이며, 왜 분리하면 안전하고 확장이 쉬워진다는 걸까?
	- 로그인 예제로 이유를 알아보자
	- 기능과 화면이 동일한 앱을 아키텍처에 따라 만들어 본다
	- 아래는 구현 내용 요약

- bare (패턴 없이 구현)
	- 패턴이 없으면 혼돈의 카오스 구조임
	- 액티비티에서 레이아웃, 비즈니스 로직, 데이터 처리 등이 모두 들어있음
	- 앱이 어떻게든 동작하긴 하지만 코드가 뒤죽박죽이라 흐름 파악이 힘듬
	- 기능 추가나 테스트도 당연히 불가능할 정도로 힘듬

- MVC
	- 컨트롤러와 모델 패키지를 만듬
	- 모델은 데이터와 비즈니스 로직을 갖고 있음
		- 앱의 UI와 관계없는 부분을 담당함
		- 로그인 정보와 로그인 판단을 담당함
	- 컨트롤러 패키지의 뷰는 화면을 담당함
		- xml 레이아웃이 MVC의 뷰임
	- 컨트롤러는 뷰와 모델간의 상호작용을 담당함 
		- 외부의 입력을 처리해서 뷰의 내용을 갱신하고 새로운 그리기를 요청
	- MVC에서 모델과 뷰가 완전히 분리되기 때문에 모델은 테스트 하기 쉬움
		- 그러나 컨트롤러는 안드로이드에 종속되기 때문에 테스트가 어려워짐
	- 안드로이드 특성상 액티비티가 뷰와 컨트롤러 역할을 동시에 수행함
		- 두 요소의 결합도가 높아지는 단점이 생김
		- 따라서 많은 코드가 컨트롤러(액티비티)에 작성됨
		- 따라서 유닛 테스트나 기능 추가가 쉽지 않아짐

- MVP
	- MVC의 문제를 해결하기 위해 등장
	- 모델, 뷰, 프레젠터의 패키지로 나눔
	- 모델
		- 내용은 MVC와 동일하지만 뷰와의 의존성이 사라짐
		- 프레젠터가 중간에 관리
	- 프레젠터
		- 본질적으론 MVC의 컨트롤러와 같은 역할
		- 뷰의 참조를 직접 거치지 않고 인터페이스를 통해 교신하기 때문에 결합이 상대적으로 느슨
		- 컨트롤러와는 달리 안드로이드의 의존성을 갖지 않기 때문에 테스트가 용이함
		- 뷰와 모델의 참조를 갖고 있어서 뷰로부터 액션을 전달받고 필요한 경우 모델로부터 데이터를 취득하여 뷰에 전달해줌
	- 뷰
		- MVC에서는 뷰와 컨트롤러를 액티비티가 겸하고 있음
		- MVP에서의 액티비티는 온전히 뷰임
		- 프레젠터 변수를 갖고 있어야 함
		- 뷰는 모델을 모르기 때문에 프레젠터를 거쳐서 가져올 수 있음
	- 데이터흐름이 단일해 지는 효과를 얻을 수 있음
		- 방금 말한대로 뷰가 모델을 모르기 때문에
		- 단점으로는 인터페이스를 구현해야 하기 때문에 구현 비용이 올라감
		- 또한 뷰와 프레젠터가 1:1 대응해야 하기 때문에 앱이 커질수록 두 요소의 의존성이 강해짐

- MVVM
	- 모델 , 뷰 , 뷰모델로 나뉨
	- 모델
		- 모델은 여전히 MVC와 동일한 역할
	- 뷰모델
		- 뷰를 만드는데 필요한 로직을 갖고 있는 모델
		- 뷰를 참조하지 않기 때문에 뷰와 1 : N 의 관계를 갖고 있음
		- 따라서 중복된 코드를 뷰모델에 묶어서 줄일 수 있게 됨
	- 뷰
		- 사용자에게 보여지는 UI 파트
		- 데이터바인딩을 통해 뷰모델로부터 통보받은 데이터를 표시하는 역할만 함
		- 뷰는 뷰모델의 데이터를 옵저브하기 때문에 UI를 갱신할 수 있음
	- 뷰와 모델사이의 의존성은 당연히 없음
	- 근데 심지어 뷰모델도 뷰의 의존성이 없음
	- MVP 처럼 단방향구조 이므로 유지보수가 용이해짐

- Android App Architecture
	- 구글은 여태 안드로이드 앱을 만드는 구체적인 방법을 제안해온 적이 없었음
	- 그러나 2017년 여러 컴포넌트와 복잡한 생명주기를 잘 다룰수 있도록 컴포넌트와 가이드를 발표함
	- 이 개념들은 2018년 Jetpack의 도입과 함께 확장됨
	- 다음과 같은 앱 아키텍쳐 라는 개념이 생성됨(그림 1)
	- AAA 란 안드로이드 아키텍처 컴포넌트를 활용해서 MVVM 패턴의 핵심 가치를 구현한 MVVM Like 패턴
	- 각 파트는 모델, 뷰, 뷰모델로 대응이 됨
	- 뷰모델은 MVVM의 뷰모델이 아닌 안드로이드 아키텍처 컴포넌트의 특정한 라이브러리를 의미함
	- 개발자들이 AAA를 통해 안정적인 MVVM 패턴을 도입할 수 있도록 함
	- 따라서 안정적인 앱, 건강한 플레이스토어 생태계를 만들 수 있음

- 2022년에는 특정 언급을 삭제하고 3개의 레이어로 다시 정의 함(그림 2)
	- UI 층은 뷰와 뷰모델이 해당
	- 데이터 층은 레포지토리와 데이터 소스가 해당
	- 도메인 층은 옵셔널이 됨
		- 유스케이스가 해당됨
	- 도메인 레이어가 없으면 뷰모델이 비즈니스 로직을 갖고 있어야 함
		- 그러면 뷰모델이 너무 비대해짐
		- 액티비티 커지는걸 막으려고 뷰모델 놓은건데 정작 뷰모델이 비대해지네?
		- 따라서 뷰모델에서 비즈니스 로직을 분리한 것이 유스케이스임
	- 도메인 층이 추가되면서 MVVM 구조보다는 엉클밥의 클린아키텍처 구조에 가까워지게 됨		
		- 이 강의의 예시 앱은 유스케이스를 적용하기엔 규모가 작음
		- 따라서 도메인층을 생략한 MVVM Like 구조로 만들꺼야
	- 아키텍처 패턴은 교과서적으로 정해진것이 아닌 집단에 따라 구조나 형태가 달라질 수 있음
		- 또 어떤 패턴이 반드시 우월할 수 는 없음
		- 구글조차 AAA는 강제가 아닌 권장사항이라고 밝힘
		- 따라서 필요에 따라 적절히 사용하면 됨
		- 하지만 잘 모르면 AAA를 도입하는 것 만으로도 앱은 더 견고하고 고품질이 됨
