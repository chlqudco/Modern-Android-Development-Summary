- 뷰모델을 설명하기 이전에 액티비티의 Lifecycle을 짚고 넘어가야 될 필요가 있다.

- 데스크탑은 프로그램 상태를 안정적으로 유지할 수 있음
	- 그러나 모바일 앱은 갑자기 전화가 오거나 폰이 꺼지는 등 프로그램이 종료되는 일이 발생할 수 있다
	- 배터리 유지가 중요하기 때문에 사용되지 않는 프로그램은 os가 강제로 종료 시키곤 한다
	- 따라서 안드로이드는 액티비티의 상태를 관리할 수 있도록 생명주기 개념을 만들었다

- 생명주기
	- 그림 4 넣기
	- 액티비티가 첫 실행 땐 onCreate, 백그라운드로 넘어가면 onPause 등의 상태가 됨
	- 예상치 못한 일로 앱이 종료될 땐, 갖고 있던 데이터를 모두 잃어버리고 onCreate로 다시 되돌아감

- 버튼을 누르면 숫자가 증가하는 단순한 앱을 예시로 듬

- 평범하게 만들었을 때는 기기를 회전하는 경우 숫자가 리셋이 됨
	- 위에 말한것 처럼 다시 onCreate가 실행되면서 변수가 초기화 되었기 때문
	- 화면이 회전되면 회전된 화면에 맞춰서 다시 뷰를 생성해야 하기 때문에 onDestroy가 불림
	- 그러나 우리는 숫자가 보존되었기를 원함
	
- onSaveInstanceState
	- 데이터를 잠시 보관하자!
	- 맵 형식으로 번들에 데이터를 저장할 수 있다
	- onCreate 에서는 널체크를 통해 값을 가져올 수 있다
	- 문제는 번들이란 형식이 거대한 데이터를 위한 클래스가 아님!
	- 50K 이하로 권장, 시리얼라이즈도 안됨
	- 따라서 값을 저장하기 위해 뷰모델이란걸 만들게 됨

- ViewModel
	- 그림 5 넣기
	- 액티비티와는 독립된 생명주기를 갖고 있다
	- 액티비티가 파괴되고 재생성되는 동안에도 뷰모델은 사라지지 않고 있음
	- 쓰려면 의존성 한줄 추가해야 됨
	- 초기화 할때 초기값을 주고 싶으면 팩토리 패턴을 사용해야 함
		- 클래스 만들고 어쩌구 뭐 하고 복잡함

- 뷰모델 객체는 by 키워드를 통해 쉽게 만들 수 있다
	- 코틀린에서 by 키워드는 위임을 의미 함
	- 이걸 쓰면 위의 개고생을 안해도 됨
	- 프래그먼트에선 activityViewModels() 를 써도 됨
		- 라이프사이크를 프래그먼트의 액티비티에 종속시키도록 함
		- 프래그먼트 사이에서 뷰모델을 공유하는 경우에 사용하면 좋음

- 앱이 강제종료된 경우에도 뷰모델 상태를 저장하고 싶으면 saveStateHandle을 사용하면 됨 
	- 강제 종료에도 살아남을 수 있음
	- 위의 번들이랑 다른놈임
	- 그림 6 넣기 (뷰모델과 save어쩌구와 영구 저장소의 차이)
	- 기본 자료형 외에 Parcelable과 Serializeable도 저장 가능
	- 구현 또 복잡해짐

