- 의존성 주입은 객체지향 프로그래밍의 개념중 하나
	- 이걸 이해하기 위해선 우선 객체지향 5대 원칙인 SOLID 원칙을 알아보자

- SOLID 원칙
	- 로버트 마틴이 발표한 기본 원칙
	- 단일 책임 원칙 (Single responsibility principle, SRP)
		- 클래스는 여러 책임을 가지면 안된다.
		- 클래스는 하나의 기능을 가지라는 뜻인가?
		- 객체가 가진 책임이 많아 질 수록 변경사항이 복잡해짐
	- 개방-폐쇄 원칙 (Open-closed principle, OCP)
		- 객체를 수정하지 않고도 기능을 확장할 수 있게 설계하라
		- 수정이 아닌 추가로써 기능을 확장할 수 있도록
	- 리스코프 치환 원칙 (Liskov substitution principle, LSP)
		- 상위 타입 객체가 하위 타입 객체로 변환 되어도 사용가능하다?
	- 인터페이스 분리 원칙 (Interface segregation principle, ISP)
		- 구현할 필요 없는 메소드를 가진 인터페이스를 사용하지 말자
	- 의존성 역전 원칙 (Dependency inversion principle, DIP)
		- 하위 모듈이 변해도 상위 모델이 변하면 안된다.
		- 잘 생각해보면 OCP를 위해 존재하는 법칙

- 의존성 주입(Dependency Injection, DI)
	- 의존관계는 꼬리에 꼬리를 무는 것처럼 전파하는 특징이 있다.
	- 근데 프로그래밍 하다 보면 순환참조(Circular reference)가 생기는 경우가 있다. 유지보수를 어렵게 하기 때문에 반드시 피해야 함.
	- 의존 역전 법칙을 프로그래밍 방식으로 적용하는 것이 안드로이드 의존성 주입 라이브러리
	- 테스트가 용이해짐 
	- Dagger / Hilt / Koin / Kodein / Anvil


- 의존성 주입 방식별 구분
	- 생성자 주입 방식 : 클래스를 초기화 할 때 외부에서 만든 클래스를 넘기는 방식
	- 메소드 주입 방식 : 초기화가 끝난 뒤의 시점에 객체를 주입하는 방식
	- 인터페이스를 통한 주입 방식 : 메소드 주입방식과 유사한테 인터페이스를 통해 주입함


- 주입방식 비교
	- 생성자 주입 방식
		- 필요한 모든 의존객체를 객체를 생성하는 시점에 준비 가능
		- 생성 시점에 의존객체가 정상인지 아닌지 판정 가능
	- 메소드와 인터페이스를 통한 주입 방식
		- 의존객체가 나중에 생성되는 경우에 사용 가능
		- 메소드의 이름을 통해 어떤 의존객체를 주입하는지 더 알기 쉬움


- 서비스 로케이터 방식
	- 의존성 주입 방식 중의 하나
	- 로케이터 클래스에 의존 객체를 모은 다음에 각 클래스에 의존 객체를 전달 하는 구조


- 서비스 로케이터의 한계
	- 인터페이스 분리원칙을 위반하게 됨
	- 동일한 의존객체를 여러 클래스에서 사용해야 할 경우, 제공 메소드를 각 객체 수만큼 준비해야 함
	- 의존성에 문제가 있어도 컴파일 타임에 확인할 수 없음
